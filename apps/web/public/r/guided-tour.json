{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "guided-tour",
  "type": "registry:component",
  "title": "Guided Tour",
  "author": "Nitish Singh <devxnitish@gmail.com>",
  "description": "An interactive guided tour component to onboard users and showcase features.",
  "registryDependencies": [
    "button",
    "card"
  ],
  "files": [
    {
      "path": "registry/new-york/guided-tour/guided-tour.tsx",
      "content": "\"use client\"\nimport React, { useState, useEffect, useRef, createContext, useContext, ReactNode, useCallback } from 'react'\nimport { Button } from '@/components/ui/button'\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'\nimport { X, ChevronLeft, ChevronRight } from 'lucide-react'\n\nconst useDisableMouseScroll = (isDisabled: boolean) => {\n  useEffect(() => {\n    if (isDisabled) {\n      const preventMouseScroll = (e: WheelEvent) => {\n        e.preventDefault();\n      };\n      window.addEventListener('wheel', preventMouseScroll, { passive: false });\n\n      return () => {\n        window.removeEventListener('wheel', preventMouseScroll);\n      };\n    }\n  }, [isDisabled]);\n};\n\ninterface TourStepConfig {\n  id: string;\n  title: string;\n  content: string;\n  position?: 'top' | 'bottom' | 'left' | 'right';\n  order: number;\n}\n\ninterface TourProviderProps {\n  children: ReactNode;\n  autoStart?: boolean;\n  ranOnce?: boolean;\n  storageKey?: string;\n  shouldStart?: boolean;\n  onTourComplete?: () => void;\n  onTourSkip?: () => void;\n}\n\ninterface TourContextType {\n  registerStep: (stepConfig: TourStepConfig, element: HTMLElement) => void;\n  unregisterStep: (id: string) => void;\n  startTour: () => void;\n  stopTour: () => void;\n  nextStep: () => void;\n  prevStep: () => void;\n  resetTourCompletion: () => void;\n  isActive: boolean;\n  currentStepId: string | null;\n  currentStepIndex: number;\n  totalSteps: number;\n}\n\nconst TourContext = createContext<TourContextType | null>(null);\n\nexport const useTour = () => {\n  const context = useContext(TourContext);\n  if (!context) {\n    throw new Error('useTour must be used within a TourProvider');\n  }\n  return context;\n};\n\nconst TourOverlay: React.FC = () => {\n  const { isActive, currentStepId } = useTour();\n  const [highlightRect, setHighlightRect] = useState<DOMRect | null>(null);\n\n  useDisableMouseScroll(isActive);\n\n  useEffect(() => {\n    if (isActive && currentStepId) {\n      const stepElement = document.querySelector(`[data-tour-step=\"${currentStepId}\"]`) as HTMLElement;\n      if (stepElement) {\n        const updateHighlight = () => {\n          const rect = stepElement.getBoundingClientRect();\n          setHighlightRect(rect);\n        };\n\n        updateHighlight();\n\n        const handleUpdate = () => updateHighlight();\n        window.addEventListener('scroll', handleUpdate, true);\n        window.addEventListener('resize', handleUpdate);\n\n        return () => {\n          window.removeEventListener('scroll', handleUpdate, true);\n          window.removeEventListener('resize', handleUpdate);\n        };\n      }\n    } else {\n      setHighlightRect(null);\n    }\n  }, [isActive, currentStepId]);\n\n  if (!isActive || !highlightRect) {\n    return null;\n  }\n\n  const padding = 8;\n\n  return (\n    <div\n      className=\"fixed inset-0 z-[10000] pointer-events-auto\"\n    >\n      <div\n        className=\"fixed inset-0 bg-black/30 z-[10001] backdrop-blur-sm pointer-events-auto\"\n      />\n      <div\n        className=\"absolute rounded-xl pointer-events-none\"\n        style={{\n          left: highlightRect.left - padding,\n          top: highlightRect.top - padding,\n          width: highlightRect.width + padding * 2,\n          height: highlightRect.height + padding * 2,\n          transition: 'all 0.3s ease'\n        }}\n      />\n    </div>\n  );\n};\n\nconst GlobalTourPopover: React.FC = () => {\n  const {\n    isActive,\n    currentStepId,\n    currentStepIndex,\n    totalSteps,\n    nextStep,\n    prevStep,\n    stopTour\n  } = useTour();\n\n  const [currentStepData, setCurrentStepData] = useState<TourStepConfig | null>(null);\n  const [targetElement, setTargetElement] = useState<HTMLElement | null>(null);\n  const [popoverPosition, setPopoverPosition] = useState<{\n    top: number;\n    left: number;\n    position: 'top' | 'bottom' | 'left' | 'right';\n  }>({ top: 0, left: 0, position: 'bottom' });\n  const popoverRef = useRef<HTMLDivElement>(null);\n\n  const calculateOptimalPosition = useCallback((targetRect: DOMRect, preferredPosition: 'top' | 'bottom' | 'left' | 'right' = 'bottom') => {\n    const popoverWidth = popoverRef.current?.offsetWidth || 320;\n    const popoverHeight = popoverRef.current?.offsetHeight || 200;\n    const margin = 16;\n\n    const viewportWidth = window.innerWidth;\n    const viewportHeight = window.innerHeight;\n    const isMobile = viewportWidth < 768;\n\n    const spaceTop = targetRect.top;\n    const spaceBottom = viewportHeight - targetRect.bottom;\n\n    let position: 'top' | 'bottom' | 'left' | 'right' = preferredPosition;\n    let top = 0;\n    let left = 0;\n\n    if (isMobile) {\n      left = (viewportWidth - popoverWidth) / 2;\n\n      const positionsToTry: ('top' | 'bottom')[] = ['bottom', 'top'];\n      if (preferredPosition === 'top') {\n        positionsToTry.reverse();\n      }\n\n      let placed = false;\n      for (const pos of positionsToTry) {\n        if (pos === 'bottom' && spaceBottom >= popoverHeight + margin) {\n          top = targetRect.bottom + margin;\n          position = 'bottom';\n          placed = true;\n          break;\n        }\n        if (pos === 'top' && spaceTop >= popoverHeight + margin) {\n          top = targetRect.top - popoverHeight - margin;\n          position = 'top';\n          placed = true;\n          break;\n        }\n      }\n\n      if (!placed) {\n        position = 'bottom';\n        top = viewportHeight - popoverHeight - margin;\n      }\n    } else {\n      const spaceLeft = targetRect.left;\n      const spaceRight = viewportWidth - targetRect.right;\n      const positionsToTry: ('top' | 'bottom' | 'left' | 'right')[] = [preferredPosition, 'bottom', 'top', 'right', 'left'];\n      const uniquePositions = [...new Set(positionsToTry)];\n\n      let placed = false;\n      for (const p of uniquePositions) {\n        if (p === 'bottom' && spaceBottom >= popoverHeight + margin) {\n          position = 'bottom';\n          top = targetRect.bottom + margin;\n          left = targetRect.left + (targetRect.width / 2) - (popoverWidth / 2);\n          placed = true;\n          break;\n        }\n        if (p === 'top' && spaceTop >= popoverHeight + margin) {\n          position = 'top';\n          top = targetRect.top - popoverHeight - margin;\n          left = targetRect.left + (targetRect.width / 2) - (popoverWidth / 2);\n          placed = true;\n          break;\n        }\n        if (p === 'right' && spaceRight >= popoverWidth + margin) {\n          position = 'right';\n          top = targetRect.top + (targetRect.height / 2) - (popoverHeight / 2);\n          left = targetRect.right + margin;\n          placed = true;\n          break;\n        }\n        if (p === 'left' && spaceLeft >= popoverWidth + margin) {\n          position = 'left';\n          top = targetRect.top + (targetRect.height / 2) - (popoverHeight / 2);\n          left = targetRect.left - popoverWidth - margin;\n          placed = true;\n          break;\n        }\n      }\n\n      if (!placed) {\n        top = (viewportHeight - popoverHeight) / 2;\n        left = (viewportWidth - popoverWidth) / 2;\n      }\n    }\n\n    top = Math.max(margin, Math.min(top, viewportHeight - popoverHeight - margin));\n    left = Math.max(margin, Math.min(left, viewportWidth - popoverWidth - margin));\n\n    return { top, left, position };\n  }, []);\n\n  useEffect(() => {\n    const updatePosition = () => {\n      if (isActive && currentStepId) {\n        const stepElement = document.querySelector(`[data-tour-step=\"${currentStepId}\"]`) as HTMLElement;\n        if (stepElement) {\n          const rect = stepElement.getBoundingClientRect();\n          const stepData = JSON.parse(stepElement.getAttribute('data-tour-config') || '{}');\n          const newPosition = calculateOptimalPosition(rect, stepData.position);\n          setPopoverPosition(newPosition);\n        }\n      }\n    };\n\n    if (isActive && currentStepId) {\n      const stepElement = document.querySelector(`[data-tour-step=\"${currentStepId}\"]`) as HTMLElement;\n      if (stepElement) {\n        const stepData = JSON.parse(stepElement.getAttribute('data-tour-config') || 'null');\n        setCurrentStepData(stepData);\n        setTargetElement(stepElement);\n\n        stepElement.scrollIntoView({\n          behavior: 'smooth',\n          block: 'center',\n          inline: 'nearest'\n        });\n\n        setTimeout(() => {\n          updatePosition();\n        }, 300);\n\n        window.addEventListener('resize', updatePosition);\n        window.addEventListener('scroll', updatePosition, true);\n\n        return () => {\n          window.removeEventListener('resize', updatePosition);\n          window.removeEventListener('scroll', updatePosition, true);\n        };\n      }\n    } else {\n      setCurrentStepData(null);\n      setTargetElement(null);\n    }\n  }, [isActive, currentStepId, calculateOptimalPosition]);\n\n  if (!currentStepData || !targetElement) {\n    return null;\n  }\n\n  const isLastStep = currentStepIndex === totalSteps - 1;\n  const isFirstStep = currentStepIndex === 0;\n\n  return (\n    <div\n      ref={popoverRef}\n      className=\"fixed z-[10003] w-80\"\n      style={{\n        top: `${popoverPosition.top}px`,\n        left: `${popoverPosition.left}px`,\n        transition: 'all 0.3s ease'\n      }}\n    >\n\n      <Card className=\"border-2 border-primary/20 backdrop-blur-sm shadow-2xl\">\n        <CardHeader className=\"pb-3\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-2\">\n              <div className=\"w-6 h-6 rounded-full bg-primary text-primary-foreground text-xs flex items-center justify-center font-semibold\">\n                {currentStepIndex + 1}\n              </div>\n              <CardTitle className=\"text-lg\">{currentStepData.title}</CardTitle>\n            </div>\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={stopTour}\n              className=\"h-6 w-6 text-muted-foreground hover:text-foreground\"\n            >\n              <X className=\"h-4 w-4\" />\n            </Button>\n          </div>\n          <div className=\"w-full bg-muted rounded-full h-1.5\">\n            <div\n              className=\"bg-primary h-1.5 rounded-full transition-all duration-300\"\n              style={{ width: `${((currentStepIndex + 1) / totalSteps) * 100}%` }}\n            />\n          </div>\n        </CardHeader>\n        <CardContent className=\"pt-0\">\n          <CardDescription className=\"text-sm leading-relaxed mb-4\">\n            {currentStepData.content}\n          </CardDescription>\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex gap-2 ml-auto\">\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={stopTour}\n                className=\"text-muted-foreground hover:text-foreground\"\n              >\n                Skip Tour\n              </Button>\n              {!isFirstStep && (\n                <Button variant=\"outline\" size=\"sm\"\n                  onClick={prevStep}>\n                  <ChevronLeft className=\"h-4 w-4 mr-1\" />\n                  Back\n                </Button>\n              )}\n              <Button size=\"sm\" onClick={nextStep}>\n                {isLastStep ? 'Finish' : 'Next'}\n                {!isLastStep && <ChevronRight className=\"h-4 w-4 ml-1\" />}\n              </Button>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n    </div>\n  );\n};\n\nexport const TourProvider: React.FC<TourProviderProps> = ({\n  children,\n  autoStart = false,\n  ranOnce = true,\n  storageKey = 'rigidui-tour-completed',\n  shouldStart = true,\n  onTourComplete,\n  onTourSkip\n}) => {\n  const [steps, setSteps] = useState<Map<string, TourStepConfig & { element: HTMLElement }>>(new Map());\n  const [isActive, setIsActive] = useState(false);\n  const [currentStep, setCurrentStep] = useState(0);\n  const [activeSteps, setActiveSteps] = useState<Array<TourStepConfig & { element: HTMLElement }>>([]);\n  const [hasAutoStarted, setHasAutoStarted] = useState(false);\n\n  const registerStep = useCallback((stepConfig: TourStepConfig, element: HTMLElement) => {\n    setSteps(prev => {\n      const newSteps = new Map(prev);\n      newSteps.set(stepConfig.id, { ...stepConfig, element });\n      return newSteps;\n    });\n  }, []);\n\n  const unregisterStep = useCallback((id: string) => {\n    setSteps(prev => {\n      const newSteps = new Map(prev);\n      newSteps.delete(id);\n      return newSteps;\n    });\n  }, []);\n\n  useEffect(() => {\n    if (autoStart && !hasAutoStarted && steps.size > 0 && shouldStart) {\n      const tourCompleted = ranOnce ? localStorage.getItem(storageKey) === 'true' : false;\n\n      if (!tourCompleted) {\n        const timer = setTimeout(() => {\n          const filteredSteps = Array.from(steps.values())\n            .sort((a, b) => a.order - b.order);\n\n          if (filteredSteps.length > 0) {\n            setActiveSteps(filteredSteps);\n            setCurrentStep(0);\n            setIsActive(true);\n          }\n          setHasAutoStarted(true);\n        }, 500);\n        return () => clearTimeout(timer);\n      } else {\n        setHasAutoStarted(true);\n      }\n    }\n  }, [autoStart, hasAutoStarted, steps, ranOnce, storageKey, shouldStart]);\n\n  const startTour = () => {\n    const filteredSteps = Array.from(steps.values())\n      .sort((a, b) => a.order - b.order);\n\n    if (filteredSteps.length > 0) {\n      setActiveSteps(filteredSteps);\n      setCurrentStep(0);\n      setIsActive(true);\n    }\n  };\n\n  const stopTour = (completed = false) => {\n    const wasActive = isActive;\n\n    setIsActive(false);\n    setCurrentStep(0);\n    setActiveSteps([]);\n\n    if (wasActive) {\n      if (completed) {\n        if (ranOnce) {\n          localStorage.setItem(storageKey, 'true');\n        }\n        if (onTourComplete) {\n          onTourComplete();\n        }\n        window.dispatchEvent(new CustomEvent('tourCompleted', { detail: { storageKey } }));\n      } else if (!completed && onTourSkip) {\n        onTourSkip();\n      }\n    }\n  };\n\n  const nextStep = () => {\n    if (currentStep < activeSteps.length - 1) {\n      const newStepIndex = currentStep + 1;\n      setCurrentStep(newStepIndex);\n    } else {\n      stopTour(true);\n    }\n  };\n\n  const prevStep = () => {\n    if (currentStep > 0) {\n      const newStepIndex = currentStep - 1;\n      setCurrentStep(newStepIndex);\n    }\n  };\n\n  const resetTourCompletion = () => {\n    if (ranOnce) {\n      localStorage.removeItem(storageKey);\n      setHasAutoStarted(false);\n      window.dispatchEvent(new CustomEvent('tourReset', { detail: { storageKey } }));\n    }\n  };\n\n  return (\n    <TourContext.Provider value={{\n      registerStep,\n      unregisterStep,\n      startTour,\n      stopTour: () => stopTour(false),\n      nextStep,\n      prevStep,\n      resetTourCompletion,\n      isActive,\n      currentStepId: activeSteps[currentStep]?.id || null,\n      currentStepIndex: currentStep,\n      totalSteps: activeSteps.length\n    }}>\n      {children}\n      <TourOverlay />\n      <GlobalTourPopover />\n    </TourContext.Provider>\n  );\n};\n\nexport const TourStep: React.FC<{\n  id: string;\n  title: string;\n  content: string;\n  order: number;\n  position?: 'top' | 'bottom' | 'left' | 'right';\n  children: ReactNode;\n}> = ({ children, id, title, content, order, position }) => {\n  const {\n    registerStep,\n    unregisterStep,\n    isActive,\n    currentStepId\n  } = useTour();\n  const elementRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (elementRef.current) {\n      const stepConfig = { id, title, content, order, position };\n      registerStep(stepConfig, elementRef.current);\n    }\n\n    return () => {\n      unregisterStep(id);\n    };\n  }, [id, title, content, order, position, registerStep, unregisterStep]);\n\n  const isCurrentStep = isActive && currentStepId === id;\n\n  return (\n    <div\n      ref={elementRef}\n      data-tour-step={id}\n      data-tour-config={JSON.stringify({ id, title, content, order, position })}\n      className={isCurrentStep ? \"relative z-[10002]\" : \"relative\"}\n    >\n      {children}\n    </div>\n  );\n};\n\nexport const TourTrigger: React.FC<{\n  children: ReactNode;\n  className?: string;\n  hideAfterComplete?: boolean;\n  storageKey?: string;\n}> = ({ children, className, hideAfterComplete = false, storageKey = 'rigidui-tour-completed' }) => {\n  const { startTour } = useTour();\n  const [tourCompleted, setTourCompleted] = useState(false);\n\n  useEffect(() => {\n    if (hideAfterComplete) {\n      const completed = localStorage.getItem(storageKey) === 'true';\n      setTourCompleted(completed);\n\n      const handleTourComplete = (event: Event) => {\n        const customEvent = event as CustomEvent;\n        const eventStorageKey = customEvent.detail?.storageKey || 'rigidui-tour-completed';\n        if (eventStorageKey === storageKey) {\n          localStorage.setItem(storageKey, 'true');\n          setTourCompleted(true);\n        }\n      };\n\n      const handleTourReset = (event: Event) => {\n        const customEvent = event as CustomEvent;\n        const eventStorageKey = customEvent.detail?.storageKey || 'rigidui-tour-completed';\n        if (eventStorageKey === storageKey) {\n          setTourCompleted(false);\n        }\n      };\n\n      window.addEventListener('tourCompleted', handleTourComplete);\n      window.addEventListener('tourReset', handleTourReset);\n\n      return () => {\n        window.removeEventListener('tourCompleted', handleTourComplete);\n        window.removeEventListener('tourReset', handleTourReset);\n      };\n    }\n  }, [hideAfterComplete, storageKey]);\n\n  const handleClick = (e: React.MouseEvent) => {\n    e.preventDefault();\n    startTour();\n  };\n\n  if (hideAfterComplete && tourCompleted) {\n    return null;\n  }\n\n  return (\n    <div onClick={handleClick} className={className}>\n      {children}\n    </div>\n  );\n};\n\nexport default TourProvider;\n",
      "type": "registry:component"
    }
  ]
}