{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "draggable-canvas",
  "type": "registry:component",
  "title": "Draggable Canvas",
  "author": "Nitish Singh <devxnitish@gmail.com>",
  "description": "A draggable canvas component to create interactive and dynamic layouts.",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "r/new-york/draggable-canvas/draggable-canvas.tsx",
      "content": "\"use client\"\nimport React, { useEffect, useRef } from 'react'\nimport { motion } from 'motion/react'\n\nexport interface DraggableCanvasItem {\n  src?: string\n  top: string\n  left: string\n  width?: number | string\n  height?: number | string\n  render?: React.ReactNode\n  hoverScale?: number\n}\n\nexport interface DraggableCanvasProps {\n  items: DraggableCanvasItem[]\n  width?: string | number \n  height?: string | number\n  showBoundary?: boolean\n  showCornerLabels?: boolean\n  className?: string\n  style?: React.CSSProperties\n  friction?: number\n  elasticity?: number\n  reboundDamping?: number\n  stopThreshold?: number\n  initialCenter?: boolean\n}\n\nexport const DraggableCanvas: React.FC<DraggableCanvasProps> = ({\n  items,\n  width = '300vw',\n  height = '150vh',\n  showBoundary = false,\n  showCornerLabels = false,\n  className = '',\n  style,\n  friction = 0.92,\n  elasticity = 0.2,\n  reboundDamping = 0.8,\n  stopThreshold = 0.01,\n  initialCenter = true\n}) => {\n  const canvasRef = useRef<HTMLDivElement | null>(null)\n  const frame = useRef(0)\n  const dragging = useRef(false)\n  const startX = useRef(0)\n  const startY = useRef(0)\n  const offsetX = useRef(0)\n  const offsetY = useRef(0)\n  const vx = useRef(0)\n  const vy = useRef(0)\n  const lastX = useRef(0)\n  const lastY = useRef(0)\n  const lastTime = useRef(0)\n  const bounds = useRef({ minX: 0, maxX: 0, minY: 0, maxY: 0 })\n  const initialized = useRef(false)\n\n  useEffect(() => {\n    const el = canvasRef.current\n    if (!el) return\n    const clamp = (v: number, min: number, max: number) => Math.min(Math.max(v, min), max)\n\n    const computeBounds = () => {\n      const vw = window.innerWidth\n      const vh = window.innerHeight\n      const w = el.offsetWidth\n      const h = el.offsetHeight\n      bounds.current.minX = w > vw ? vw - w : 0\n      bounds.current.maxX = 0\n      bounds.current.minY = h > vh ? vh - h : 0\n      bounds.current.maxY = 0\n      if (!initialized.current) {\n        if (initialCenter && (w > vw || h > vh)) {\n          offsetX.current = w > vw ? (vw - w) / 2 : 0\n          offsetY.current = h > vh ? (vh - h) / 2 : 0\n        } else {\n          offsetX.current = clamp(offsetX.current, bounds.current.minX, bounds.current.maxX)\n          offsetY.current = clamp(offsetY.current, bounds.current.minY, bounds.current.maxY)\n        }\n        initialized.current = true\n      } else {\n        offsetX.current = clamp(offsetX.current, bounds.current.minX, bounds.current.maxX)\n        offsetY.current = clamp(offsetY.current, bounds.current.minY, bounds.current.maxY)\n      }\n      el.style.transform = `translate3d(${offsetX.current}px, ${offsetY.current}px,0)`\n    }\n    computeBounds()\n    const onResize = () => computeBounds()\n    window.addEventListener('resize', onResize)\n\n    const onDown = (cx: number, cy: number) => {\n      dragging.current = true\n      startX.current = cx - offsetX.current\n      startY.current = cy - offsetY.current\n      lastX.current = cx\n      lastY.current = cy\n      lastTime.current = performance.now()\n      vx.current = 0\n      vy.current = 0\n    }\n    const onMoveDrag = (cx: number, cy: number) => {\n      if (!dragging.current) return\n      const now = performance.now()\n      const dt = now - lastTime.current\n      if (dt > 0) {\n        vx.current = ((cx - lastX.current) / dt) * 16\n        vy.current = ((cy - lastY.current) / dt) * 16\n      }\n      offsetX.current = cx - startX.current\n      offsetY.current = cy - startY.current\n      lastX.current = cx\n      lastY.current = cy\n      lastTime.current = now\n    }\n    const onUp = () => { dragging.current = false }\n\n    const pointerDown = (e: MouseEvent) => { e.preventDefault(); onDown(e.clientX, e.clientY) }\n    const pointerMove = (e: MouseEvent) => onMoveDrag(e.clientX, e.clientY)\n    const pointerUp = () => onUp()\n    const touchStart = (e: TouchEvent) => { const t = e.touches[0]; onDown(t.clientX, t.clientY) }\n    const touchMove = (e: TouchEvent) => { const t = e.touches[0]; onMoveDrag(t.clientX, t.clientY) }\n    const touchEnd = () => onUp()\n\n    el.addEventListener('mousedown', pointerDown)\n    window.addEventListener('mousemove', pointerMove)\n    window.addEventListener('mouseup', pointerUp)\n    el.addEventListener('touchstart', touchStart, { passive: false })\n    window.addEventListener('touchmove', touchMove, { passive: false })\n    window.addEventListener('touchend', touchEnd)\n\n    const applyBounds = () => {\n      if (offsetX.current < bounds.current.minX) {\n        const o = bounds.current.minX - offsetX.current\n        offsetX.current = bounds.current.minX + o * elasticity\n        vx.current *= reboundDamping\n      } else if (offsetX.current > bounds.current.maxX) {\n        const o = offsetX.current - bounds.current.maxX\n        offsetX.current = bounds.current.maxX + o * elasticity\n        vx.current *= reboundDamping\n      }\n      if (offsetY.current < bounds.current.minY) {\n        const o = bounds.current.minY - offsetY.current\n        offsetY.current = bounds.current.minY + o * elasticity\n        vy.current *= reboundDamping\n      } else if (offsetY.current > bounds.current.maxY) {\n        const o = offsetY.current - bounds.current.maxY\n        offsetY.current = bounds.current.maxY + o * elasticity\n        vy.current *= reboundDamping\n      }\n    }\n\n    const loop = () => {\n      if (!dragging.current) {\n        offsetX.current += vx.current\n        offsetY.current += vy.current\n        vx.current *= friction\n        vy.current *= friction\n        if (Math.abs(vx.current) < stopThreshold) vx.current = 0\n        if (Math.abs(vy.current) < stopThreshold) vy.current = 0\n      }\n      applyBounds()\n      el.style.transform = `translate3d(${offsetX.current}px, ${offsetY.current}px,0)`\n      frame.current = requestAnimationFrame(loop)\n    }\n    frame.current = requestAnimationFrame(loop)\n\n    return () => {\n      window.removeEventListener('resize', onResize)\n      el.removeEventListener('mousedown', pointerDown)\n      window.removeEventListener('mousemove', pointerMove)\n      window.removeEventListener('mouseup', pointerUp)\n      el.removeEventListener('touchstart', touchStart)\n      window.removeEventListener('touchmove', touchMove)\n      window.removeEventListener('touchend', touchEnd)\n      cancelAnimationFrame(frame.current)\n    }\n  }, [elasticity, friction, reboundDamping, stopThreshold, initialCenter])\n\n  return (\n    <div\n      ref={canvasRef}\n      className={\n        `absolute top-0 left-0 ${showBoundary ? 'draggable-boundary' : ''} ${className}`\n      }\n      style={{\n        width,\n        height,\n        backgroundImage: 'radial-gradient(circle at center, rgba(0,0,0,0.05) 1px, transparent 1px)',\n        backgroundSize: '40px 40px',\n        ...style\n      }}\n    >\n      {showBoundary && showCornerLabels && (\n        <>\n          <div className=\"dc-corner tl\">TL</div>\n          <div className=\"dc-corner tr\">TR</div>\n          <div className=\"dc-corner bl\">BL</div>\n          <div className=\"dc-corner br\">BR</div>\n        </>\n      )}\n      {items.map((item, i) => {\n        const content = item.render ?? (\n          <motion.img\n            src={item.src}\n            alt={item.src || `item-${i}`}\n            className=\"w-full h-full object-contain\"\n            whileHover={{ scale: item.hoverScale ?? 1.05 }}\n            transition={{ type: 'spring', stiffness: 260, damping: 20 }}\n          />\n        )\n        return (\n          <motion.div\n            key={i}\n            className=\"absolute overflow-hidden will-change-transform draggable-item\"\n            style={{\n              top: item.top,\n              left: item.left,\n              width: item.width ?? 320,\n              height: item.height ?? 440\n            }}\n            whileHover={{ scale: item.hoverScale ?? 1.05 }}\n            transition={{ type: 'spring', stiffness: 260, damping: 20 }}\n          >\n            {content}\n          </motion.div>\n        )\n      })}\n      <style jsx global>{`\n        .draggable-boundary{border:2px dashed #444;}\n        .draggable-boundary .dc-corner{position:absolute;width:38px;height:38px;display:flex;align-items:center;justify-content:center;font-size:10px;letter-spacing:.5px;font-weight:500;background:#1c1c1c;border:1px solid #555;border-radius:6px;color:#777;user-select:none;}\n        .draggable-boundary .dc-corner.tl{top:0;left:0;transform:translate(-45%,-45%)}\n        .draggable-boundary .dc-corner.tr{top:0;right:0;transform:translate(45%,-45%)}\n        .draggable-boundary .dc-corner.bl{bottom:0;left:0;transform:translate(-45%,45%)}\n        .draggable-boundary .dc-corner.br{bottom:0;right:0;transform:translate(45%,45%)}\n        .draggable-item{transition:box-shadow .3s ease; width: var(--draggable-item-width); height: var(--draggable-item-height);}\n        .draggable-item:hover{box-shadow:0 8px 25px rgba(0,0,0,.2)}\n      `}</style>\n    </div>\n  )\n}\n\nexport default DraggableCanvas\n",
      "type": "registry:component"
    }
  ]
}