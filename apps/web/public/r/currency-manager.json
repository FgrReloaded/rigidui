{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "currency-manager",
  "type": "registry:component",
  "title": "Currency Manager",
  "author": "Nitish Singh <devxnitish@gmail.com>",
  "description": "A currency manager component",
  "registryDependencies": [
    "select"
  ],
  "files": [
    {
      "path": "registry/new-york/currency-manager/currency-manager.tsx",
      "content": "\"use client\"\n\nimport { createContext, useContext, useState, ReactNode, useEffect, ComponentType, useCallback } from 'react'\nimport { Button } from \"@/components/ui/button\"\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"@/components/ui/command\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\"\nimport { Loader, Check } from 'lucide-react'\nimport { cn } from '@/lib/utils'\n\nexport type Currency = {\n  code: string\n  name: string\n}\n\nconst CURRENCY_NAMES_API_URL = \"https://cdn.jsdelivr.net/npm/@fgrreloaded/currencies@latest/v1/currencies.json\";\n\nconst CURRENCY_CACHE_KEY = 'rigidui_currency_names';\nconst SELECTED_CURRENCY_KEY = 'rigidui_selected_currency';\nconst RATES_CACHE_KEY = 'rigidui_exchange_rates';\nconst CURRENCY_CACHE_DURATION = 24 * 60 * 60 * 1000;\n\ninterface CachedRates {\n  rates: Record<string, number>;\n  timestamp: number;\n  baseCurrency: string;\n}\n\ninterface CachedCurrencies {\n  data: Currency[];\n  timestamp: number;\n}\n\nconst safeLocalStorage = {\n  getItem: (key: string): string | null => {\n    try {\n      return typeof window !== 'undefined' ? localStorage.getItem(key) : null;\n    } catch {\n      return null;\n    }\n  },\n  setItem: (key: string, value: string): void => {\n    try {\n      if (typeof window !== 'undefined') {\n        localStorage.setItem(key, value);\n      }\n    } catch {\n    }\n  },\n  removeItem: (key: string): void => {\n    try {\n      if (typeof window !== 'undefined') {\n        localStorage.removeItem(key);\n      }\n    } catch {\n    }\n  }\n};\n\nconst getCachedCurrencies = (): Currency[] | null => {\n  try {\n    const cached = safeLocalStorage.getItem(CURRENCY_CACHE_KEY);\n    if (!cached) return null;\n\n    const { data, timestamp }: CachedCurrencies = JSON.parse(cached);\n    if (Date.now() - timestamp > CURRENCY_CACHE_DURATION) {\n      safeLocalStorage.removeItem(CURRENCY_CACHE_KEY);\n      return null;\n    }\n    return data;\n  } catch {\n    return null;\n  }\n};\n\nconst setCachedCurrencies = (currencies: Currency[]) => {\n  try {\n    safeLocalStorage.setItem(CURRENCY_CACHE_KEY, JSON.stringify({\n      data: currencies,\n      timestamp: Date.now()\n    }));\n  } catch {\n  }\n};\n\nconst getStoredCurrency = (): string | null => {\n  return safeLocalStorage.getItem(SELECTED_CURRENCY_KEY);\n};\n\nconst setStoredCurrency = (currencyCode: string) => {\n  safeLocalStorage.setItem(SELECTED_CURRENCY_KEY, currencyCode);\n};\n\nconst getCachedRates = (baseCurrency: string): { rates: Record<string, number>, timestamp: number } | null => {\n  try {\n    const cached = safeLocalStorage.getItem(RATES_CACHE_KEY);\n    if (!cached) return null;\n\n    const { rates, timestamp, baseCurrency: cachedBase }: CachedRates = JSON.parse(cached);\n\n    if (cachedBase !== baseCurrency) return null;\n\n    return { rates, timestamp };\n  } catch {\n    return null;\n  }\n};\n\nconst setCachedRates = (rates: Record<string, number>, baseCurrency: string) => {\n  try {\n    safeLocalStorage.setItem(RATES_CACHE_KEY, JSON.stringify({\n      rates,\n      timestamp: Date.now(),\n      baseCurrency\n    }));\n  } catch {\n  }\n};\n\nconst shouldRefetchRates = (refetchIntervalMs?: number, lastFetchTimestamp?: number): boolean => {\n  if (!refetchIntervalMs || !lastFetchTimestamp) return true;\n  return Date.now() - lastFetchTimestamp > refetchIntervalMs;\n};\n\nconst DefaultLoader = () => <Loader className='w-4 h-4 animate-spin dark:text-gray-300' />;\n\ntype CurrencyContextType = {\n  currency: Currency | undefined\n  setCurrency: (currency: Currency) => void\n  formatValue: (value: number) => string\n  convertValue: (value: number, fromCurrencyCode?: string) => number\n  rates: Record<string, number>\n  loadingRates: boolean\n  ratesError: string | null\n  LoaderComponent: ComponentType\n  availableCurrencies: Currency[]\n  loadingCurrencies: boolean\n  currenciesError: string | null\n  fixedBaseCurrencyCode: string\n  lastRatesUpdate: number | null\n}\n\nconst CurrencyContext = createContext<CurrencyContextType | undefined>(undefined)\n\ninterface CurrencyProviderProps {\n  children: ReactNode;\n  loaderComponent?: ComponentType;\n  fixedBaseCurrencyCode: string;\n  initialRates?: Record<string, number>;\n  fetchRatesFunction?: () => Promise<Record<string, number>>;\n  refetchIntervalMs?: number;\n  defaultSelectedCurrencyCode?: string;\n}\n\nexport function CurrencyProvider({\n  children,\n  loaderComponent = DefaultLoader,\n  fixedBaseCurrencyCode,\n  initialRates,\n  fetchRatesFunction,\n  refetchIntervalMs,\n  defaultSelectedCurrencyCode = \"inr\",\n}: CurrencyProviderProps) {\n  const [availableCurrencies, setAvailableCurrencies] = useState<Currency[]>([])\n  const [loadingCurrencies, setLoadingCurrencies] = useState(true);\n  const [currenciesError, setCurrenciesError] = useState<string | null>(null);\n\n  const [currency, setCurrency] = useState<Currency | undefined>(undefined)\n  const [rates, setRates] = useState<Record<string, number>>(initialRates || {})\n  const [loadingRates, setLoadingRates] = useState(false)\n  const [ratesError, setRatesError] = useState<string | null>(null)\n  const [lastRatesUpdate, setLastRatesUpdate] = useState<number | null>(null)\n\n  useEffect(() => {\n    const fetchCurrencyNames = async () => {\n      setLoadingCurrencies(true);\n      setCurrenciesError(null);\n\n      const cachedCurrencies = getCachedCurrencies();\n      if (cachedCurrencies && cachedCurrencies.length > 0) {\n        setAvailableCurrencies(cachedCurrencies);\n\n        const storedCurrencyCode = getStoredCurrency();\n        const targetCurrency = storedCurrencyCode || defaultSelectedCurrencyCode;\n        const selectedCurrency = cachedCurrencies.find(c => c.code === targetCurrency) || cachedCurrencies[0];\n        setCurrency(selectedCurrency);\n\n        setLoadingCurrencies(false);\n        return;\n      }\n\n      try {\n        const response = await fetch(CURRENCY_NAMES_API_URL);\n        if (!response.ok) {\n          throw new Error(`Failed to fetch currency names: ${response.statusText}`);\n        }\n        const data: Record<string, string> = await response.json();\n        const loadedCurrencies: Currency[] = Object.entries(data)\n          .map(([code, name]) => ({ code, name }))\n          .sort((a, b) => a.name.localeCompare(b.name));\n\n        setAvailableCurrencies(loadedCurrencies);\n        setCachedCurrencies(loadedCurrencies);\n\n        if (loadedCurrencies.length > 0) {\n          const storedCurrencyCode = getStoredCurrency();\n          const targetCurrency = storedCurrencyCode || defaultSelectedCurrencyCode;\n          const selectedCurrency = loadedCurrencies.find(c => c.code === targetCurrency) || loadedCurrencies[0];\n          setCurrency(selectedCurrency);\n        } else {\n          setCurrency(undefined);\n        }\n\n      } catch (err) {\n        console.error(\"Currency names API error:\", err);\n        setCurrenciesError(err instanceof Error ? err.message : \"Failed to fetch currency names\");\n        setAvailableCurrencies([]);\n        setCurrency(undefined);\n      } finally {\n        setLoadingCurrencies(false);\n      }\n    };\n\n    fetchCurrencyNames();\n  }, [defaultSelectedCurrencyCode]);\n\n\n  const handleFetchRates = useCallback(async () => {\n    const cachedData = getCachedRates(fixedBaseCurrencyCode);\n    if (cachedData && !shouldRefetchRates(refetchIntervalMs, cachedData.timestamp)) {\n      setRates(cachedData.rates);\n      setLastRatesUpdate(cachedData.timestamp);\n      return;\n    }\n\n    if (!fetchRatesFunction) {\n      if (initialRates) {\n        setRates(initialRates);\n        setCachedRates(initialRates, fixedBaseCurrencyCode);\n        setLastRatesUpdate(Date.now());\n      }\n      return;\n    }\n\n    setLoadingRates(true);\n    setRatesError(null);\n    try {\n      const newRates = await fetchRatesFunction();\n      const timestamp = Date.now();\n      setRates(newRates);\n      setLastRatesUpdate(timestamp);\n      setCachedRates(newRates, fixedBaseCurrencyCode);\n      console.log(`Fetched new rates relative to base: ${fixedBaseCurrencyCode}`, newRates);\n    } catch (err) {\n      console.error(\"User provided fetchRatesFunction error:\", err);\n      setRatesError(err instanceof Error ? err.message : \"Failed to fetch exchange rates via provided function\");\n\n      if (cachedData) {\n        setRates(cachedData.rates);\n        setLastRatesUpdate(cachedData.timestamp);\n        console.log(\"Using cached rates as fallback\");\n      }\n    } finally {\n      setLoadingRates(false);\n    }\n  }, [fetchRatesFunction, fixedBaseCurrencyCode, initialRates, refetchIntervalMs]);\n\n  useEffect(() => {\n    handleFetchRates();\n\n    if (fetchRatesFunction && refetchIntervalMs && refetchIntervalMs > 0) {\n      const intervalId = setInterval(() => {\n        if (shouldRefetchRates(refetchIntervalMs, lastRatesUpdate ?? undefined)) {\n          handleFetchRates();\n        }\n      }, refetchIntervalMs);\n      return () => clearInterval(intervalId);\n    }\n  }, [handleFetchRates, refetchIntervalMs, fetchRatesFunction, lastRatesUpdate]);\n\n\n  const convertValue = useCallback((value: number, fromCurrencyCode?: string) => {\n    if (!currency || Object.keys(rates).length === 0) return value;\n\n    const toCurrencyCode = currency.code;\n    const sourceCurrencyCode = fromCurrencyCode || fixedBaseCurrencyCode;\n\n    if (sourceCurrencyCode === toCurrencyCode) return value;\n\n    const effectiveRates = { ...rates, [fixedBaseCurrencyCode]: 1.0 };\n\n    const fromRate = effectiveRates[sourceCurrencyCode];\n    const toRate = effectiveRates[toCurrencyCode];\n\n    if (typeof fromRate !== 'number' || typeof toRate !== 'number') {\n      console.warn(`Cannot convert: Missing rate for ${sourceCurrencyCode} or ${toCurrencyCode}. Rates available:`, effectiveRates);\n      return value;\n    }\n\n    const valueInBase = value / fromRate;\n    return valueInBase * toRate;\n\n  }, [currency, rates, fixedBaseCurrencyCode]);\n\n\n  const formatValue = (value: number) => {\n    if (!currency) return String(value);\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency: currency.code,\n      currencyDisplay: 'symbol',\n    }).format(value)\n  }\n\n  const handleCurrencyChange = (newCurrency: Currency) => {\n    setCurrency(newCurrency);\n    setStoredCurrency(newCurrency.code);\n  };\n\n  const LoaderToShow = loaderComponent;\n\n  if (loadingCurrencies) {\n    return <div className=\"flex justify-center items-center min-h-[200px] p-4\"><LoaderToShow /> <span className=\"ml-2\">Loading currencies...</span></div>;\n  }\n\n  if (currenciesError) {\n    return <div className=\"text-red-500 p-4\">Error loading currencies: {currenciesError}</div>;\n  }\n\n  if (ratesError && Object.keys(rates).length === 0) {\n    return (\n      <div className=\"bg-yellow-50 dark:bg-yellow-950 border border-yellow-200 dark:border-yellow-800 rounded-lg p-4\">\n        <p className=\"text-yellow-800 dark:text-yellow-200\">\n          <strong>Warning:</strong> Failed to fetch exchange rates: {ratesError}\n          {initialRates && Object.keys(initialRates).length > 0 && (\n            <span className=\"block mt-1 text-sm\">Using initial rates as fallback.</span>\n          )}\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <CurrencyContext.Provider value={{\n      currency,\n      setCurrency: handleCurrencyChange,\n      formatValue,\n      convertValue,\n      rates,\n      loadingRates,\n      ratesError,\n      LoaderComponent: loaderComponent,\n      availableCurrencies,\n      loadingCurrencies,\n      currenciesError,\n      fixedBaseCurrencyCode,\n      lastRatesUpdate,\n    }}>\n      {children}\n    </CurrencyContext.Provider>\n  )\n}\n\nfunction useCurrency() {\n  const context = useContext(CurrencyContext)\n  if (context === undefined) {\n    throw new Error('useCurrency must be used within a CurrencyProvider')\n  }\n  return context\n}\n\nexport function CurrencySelector({ className }: { className?: string }) {\n  const { currency, setCurrency, loadingRates, availableCurrencies, loadingCurrencies } = useCurrency()\n  const [open, setOpen] = useState(false)\n\n  if (loadingCurrencies || !currency) {\n    return (\n      <Button\n        variant=\"outline-solid\"\n        role=\"combobox\"\n        disabled={true}\n        className={cn(\"w-[200px] justify-between\", className)}\n      >\n        Loading currencies...\n        <Loader className=\"ml-2 h-4 w-4 animate-spin\" />\n      </Button>\n    )\n  }\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"outline-solid\"\n          role=\"combobox\"\n          aria-expanded={open}\n          className={cn(\"w-fit justify-between\", className)}\n          disabled={loadingRates || availableCurrencies.length === 0}\n        >\n          {currency ? `${currency.code} - ${currency.name.slice(0, 20)}` : \"Select currency...\"}\n          {/* <ChevronsUpDown className=\"ml-2 h-4 w-4 shrink-0 opacity-50\" /> */}\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent className=\"w-[300px] p-0\">\n        <Command>\n          <CommandInput placeholder=\"Search currencies...\" className=\"h-9\" />\n          <CommandList>\n            <CommandEmpty>No currency found.</CommandEmpty>\n            <CommandGroup>\n              {availableCurrencies.map((c) => (\n                <CommandItem\n                  key={c.code}\n                  value={`${c.code} ${c.name}`}\n                  onSelect={() => {\n                    setCurrency(c)\n                    setOpen(false)\n                  }}\n                >\n                  <div className=\"flex flex-col\">\n                    <span className=\"font-medium\">{c.code}</span>\n                    <span className=\"text-sm text-muted-foreground\">{c.name}</span>\n                  </div>\n                  <Check\n                    className={cn(\n                      \"ml-auto h-4 w-4\",\n                      currency?.code === c.code ? \"opacity-100\" : \"opacity-0\"\n                    )}\n                  />\n                </CommandItem>\n              ))}\n            </CommandGroup>\n          </CommandList>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  )\n}\n\ninterface CurrencyDisplayProps {\n  value: number\n  className?: string\n  sourceCurrency?: string\n}\n\nexport function CurrencyDisplay({\n  value,\n  className,\n  sourceCurrency\n}: CurrencyDisplayProps) {\n  const {\n    formatValue,\n    convertValue,\n    loadingRates,\n    LoaderComponent,\n    currency,\n    fixedBaseCurrencyCode\n  } = useCurrency()\n\n  const actualSourceCurrency = sourceCurrency || fixedBaseCurrencyCode;\n\n  const convertedValue = currency ? convertValue(value, actualSourceCurrency) : value;\n\n  return (\n    <span className={cn(\"dark:text-gray-100\", className)}>\n      {loadingRates ? <span className='inline dark:text-gray-300'><LoaderComponent /></span> : formatValue(convertedValue)}\n    </span>\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}