{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "infinite-scroll",
  "type": "registry:component",
  "title": "Infinite Scroll",
  "author": "Nitish Singh <devxnitish@gmail.com>",
  "description": "An infinite scroll component",
  "dependencies": [
    "@tanstack/react-virtual"
  ],
  "files": [
    {
      "path": "r/new-york/infinite-scroll/infinite-scroll.tsx",
      "content": "\"use client\"\n\nimport React, { useEffect, useRef, useCallback, useState } from 'react'\nimport { useVirtualizer } from '@tanstack/react-virtual'\nimport { cn } from '@/lib/utils'\n\nconst DefaultLoader = () => (\n  <div className=\"flex justify-center py-4\">\n    <div className=\"animate-spin rounded-full h-6 w-6 border-b-2 border-primary\"></div>\n  </div>\n)\n\nconst DefaultEndMessage = () => (\n  <div className=\"text-center py-4 text-muted-foreground\">\n    <p>No more items to load</p>\n  </div>\n)\n\ninterface InfiniteScrollProps<T> {\n  items: T[];\n  hasNextPage: boolean;\n  isLoading: boolean;\n  onLoadMore: () => void | Promise<void>;\n  threshold?: number;\n  loader?: React.ComponentType;\n  endMessage?: React.ReactNode;\n  errorMessage?: React.ReactNode;\n  renderItem: (item: T, index?: number) => React.ReactNode;\n  className?: string;\n  itemClassName?: string;\n  reverse?: boolean;\n  initialLoad?: boolean;\n  scrollableTarget?: string;\n  virtualized?: boolean;\n  estimateSize?: () => number;\n  height?: number;\n  overscan?: number;\n}\n\nexport function InfiniteScroll<T>({\n  items,\n  hasNextPage,\n  isLoading,\n  onLoadMore,\n  threshold = 100,\n  loader: Loader = DefaultLoader,\n  endMessage = <DefaultEndMessage />,\n  errorMessage,\n  renderItem,\n  className,\n  itemClassName,\n  reverse = false,\n  initialLoad = false,\n  scrollableTarget,\n  virtualized = false,\n  estimateSize = () => 50,\n  height = 400,\n  overscan = 5,\n}: InfiniteScrollProps<T>) {\n  const containerRef = useRef<HTMLDivElement>(null)\n  const observerRef = useRef<IntersectionObserver | null>(null)\n  const loadingRef = useRef<HTMLDivElement>(null)\n  const [internalLoading, setInternalLoading] = useState(false)\n\n  const allRows = virtualized ? items.length + (hasNextPage ? 1 : 0) : items.length\n\n  const virtualizer = useVirtualizer({\n    count: allRows,\n    getScrollElement: () => containerRef.current,\n    estimateSize,\n    overscan,\n    enabled: virtualized,\n    measureElement: (el) => (el as HTMLElement).getBoundingClientRect().height,\n  })\n\n  const handleObserver = useCallback(\n    (entries: IntersectionObserverEntry[]) => {\n      const [target] = entries\n      if (target.isIntersecting && hasNextPage && !isLoading && !internalLoading) {\n        setInternalLoading(true)\n        Promise.resolve(onLoadMore()).finally(() => {\n          setInternalLoading(false)\n        })\n      }\n    },\n    [hasNextPage, isLoading, internalLoading, onLoadMore]\n  )\n\n  const fetchMoreOnBottomReached = useCallback(async () => {\n    if (internalLoading || !hasNextPage) return\n    setInternalLoading(true)\n    try {\n      await Promise.resolve(onLoadMore())\n    } finally {\n      setInternalLoading(false)\n    }\n  }, [hasNextPage, internalLoading, onLoadMore])\n\n  useEffect(() => {\n    if (virtualized) return;\n\n    const element = loadingRef.current\n    if (!element) return\n\n    if (observerRef.current) {\n      observerRef.current.disconnect()\n    }\n\n    observerRef.current = new IntersectionObserver(handleObserver, {\n      root: scrollableTarget ? document.getElementById(scrollableTarget) : null,\n      rootMargin: `${threshold}px`,\n      threshold: 0.1,\n    })\n\n    observerRef.current.observe(element)\n\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect()\n      }\n    }\n  }, [handleObserver, threshold, scrollableTarget, virtualized])\n\n  useEffect(() => {\n    if (!virtualized) return\n\n    const el = containerRef.current\n    if (!el) return\n\n    const onScroll = () => {\n      const nearBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - threshold\n      if (nearBottom && hasNextPage && !isLoading && !internalLoading) {\n        fetchMoreOnBottomReached()\n      }\n    }\n\n    el.addEventListener('scroll', onScroll)\n    onScroll()\n\n    return () => {\n      el.removeEventListener('scroll', onScroll)\n    }\n  }, [virtualized, threshold, hasNextPage, isLoading, internalLoading, fetchMoreOnBottomReached])\n\n  useEffect(() => {\n    if (initialLoad && items.length === 0 && hasNextPage && !isLoading) {\n      onLoadMore()\n    }\n  }, [initialLoad, items.length, hasNextPage, isLoading, onLoadMore])\n\n  const renderItems = () => {\n    const renderedItems = items.map((item, index) => (\n      <div key={index} className={cn(itemClassName)}>\n        {renderItem(item, index)}\n      </div>\n    ))\n\n    return reverse ? renderedItems.reverse() : renderedItems\n  }\n\n  if (virtualized && virtualizer) {\n    const virtualItems = virtualizer.getVirtualItems()\n    const paddingTop = virtualItems.length > 0 ? virtualItems[0].start : 0\n    const paddingBottom = virtualItems.length > 0\n      ? virtualizer.getTotalSize() - virtualItems[virtualItems.length - 1].end\n      : 0\n\n    return (\n      <div\n        ref={containerRef}\n        className={cn(\"overflow-auto\")}\n        style={{ height }}\n        role=\"feed\"\n        aria-busy={isLoading}\n        aria-label=\"Scrollable content list\"\n      >\n        <div\n          className={cn(className)}\n          style={{ paddingTop, paddingBottom }}\n        >\n          {virtualItems.map((virtualItem) => {\n            const isLoaderRow = virtualItem.index > items.length - 1\n            const item = items[virtualItem.index]\n\n            return (\n              <div\n                key={virtualItem.index}\n                ref={(el) => {\n                  if (el) virtualizer.measureElement(el)\n                }}\n                className={cn(itemClassName)}\n              >\n                {isLoaderRow ? (\n                  hasNextPage ? (\n                    (isLoading || internalLoading) ? <Loader /> : null\n                  ) : (\n                    items.length > 0 ? endMessage : (\n                      <div className=\"text-center py-8 text-muted-foreground\">\n                        <p>No items found</p>\n                      </div>\n                    )\n                  )\n                ) : (\n                  renderItem(item, virtualItem.index)\n                )}\n              </div>\n            )\n          })}\n        </div>\n\n        {errorMessage && (\n          <div className=\"text-center py-4 text-destructive\">\n            {errorMessage}\n          </div>\n        )}\n      </div>\n    )\n  }\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn(\"space-y-4\", className)}\n      style={reverse ? { display: 'flex', flexDirection: 'column-reverse' } : undefined}\n      role=\"feed\"\n      aria-busy={isLoading}\n      aria-label=\"Scrollable content list\"\n    >\n      {renderItems()}\n\n      <div ref={loadingRef} className=\"h-1\" />\n\n      {isLoading && <Loader />}\n\n      {errorMessage && (\n        <div className=\"text-center py-4 text-destructive\">\n          {errorMessage}\n        </div>\n      )}\n\n      {!hasNextPage && !isLoading && items.length > 0 && endMessage}\n\n      {!hasNextPage && !isLoading && items.length === 0 && (\n        <div className=\"text-center py-8 text-muted-foreground\">\n          <p>No items found</p>\n        </div>\n      )}\n    </div>\n  )\n}\n\nexport type { InfiniteScrollProps }",
      "type": "registry:component"
    }
  ]
}